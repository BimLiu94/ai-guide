# Vibe Coding Performance Optimization Tips

> Make Your Application Run Faster

Hello, I'm Yupi.

In Vibe Coding, you might have encountered situations where the application generated by AI functions correctly but is a bit slow. For example, pages take several seconds to load, buttons respond sluggishly, and scrolling lists feel choppy. This not only affects user experience but also makes it unpleasant for you to use.

This is a performance issue, one of the common problems with AI-generated code. AI focuses more on "whether it works" and often overlooks "how fast it runs." In Vibe Coding, we aim for rapid functionality implementation, but that doesn't mean sacrificing performance. Fortunately, performance optimization can also be achieved with the help of AI.

Below, I'll teach you how to identify performance bottlenecks in Vibe Coding and how to leverage AI to optimize performance. Even if you don't understand the technical principles, you can make your application run faster.

## 1. Identifying Performance Issues

Before optimizing, you need to know where the problems lie.

First, understand that performance is not an abstract concept but a real user experience. Users care about: How fast does the page load? How quickly do buttons respond? Is scrolling smooth?

Nowadays, users have increasingly high expectations for performance. If your page takes more than 3 seconds to load, users might leave. If a button click doesn't provide immediate feedback, users might think the page is frozen.

So, the first step in optimizing performance is to experience your application's speed from the user's perspective.

### Using Performance Testing Tools

In addition to subjective experience, use tools to measure objectively. Don't worry, these tools are simple and don't require programming knowledge.

1) Browser Developer Tools

Press F12 to open the developer tools, switch to the Performance tab, click the record button, interact with your application, and then stop the recording. You'll see a detailed performance report, including how long each operation took, which functions are the slowest, and whether there are any stutters.

![](https://pic.yupi.icu/1/image-20260105150358449.png)

If you don't understand the data, that's okay. You can take a screenshot and ask AI to analyze it:

```markdown
Here is my performance report screenshot. Please help me identify the performance bottlenecks.
```

2) Lighthouse

Chrome's built-in performance testing tool. In the developer tools' Lighthouse tab, click "Analyze page load," and it will score your page and provide optimization suggestions.

![](https://pic.yupi.icu/1/image-20260105150513178.png)

Focus on these metrics:

- LCP (Largest Contentful Paint): Should be within 2.5 seconds
- FID (First Input Delay): Should be within 100 milliseconds
- CLS (Cumulative Layout Shift): Should be less than 0.1

![](https://pic.yupi.icu/1/image-20260105150756392.png)

3) Other Online Tools

You can also use tools like PageSpeed Insights and GTmetrix to test your website's performance from a real user's perspective.

### Finding Performance Bottlenecks

After testing, you'll identify some slow areas. Don't rush to optimize all issues; first, find the most critical bottleneck.

Generally, AI-generated code has performance bottlenecks in these areas:

- JavaScript files are too large, causing slow loading
- API requests are too slow or too numerous
- Complex rendering logic leads to page stutters
- Slow database queries or too many queries
- Referenced resources are too large and not compressed or optimized

Once you find the bottleneck, prioritize optimizing the one with the most significant impact. You can directly send the test results and code to AI to help locate the issue:

```markdown
My application loads slowly. Here are the performance test results [paste test results], and here is the relevant code [paste code]. Please help me identify the problem and provide an optimization solution.
```

## 2. Common Performance Bottlenecks

Based on my experience, here are some common performance bottlenecks in AI-generated code. Understanding these issues will help you better guide AI to generate high-performance code.

### Unnecessary Re-renders

In front-end frameworks like React, components re-render for various reasons. If rendering is too frequent, the page will stutter.

AI-generated code might overlook this issue because it focuses more on functionality. Common causes include: all child components re-render when the parent component updates, even if their data hasn't changed; new functions or objects are created on each render, causing child components to think the data has changed; state updates are too frequent, such as triggering complex calculations on every input in a text field.

How to let AI help you optimize?

You can tell AI:

```markdown
This component re-renders too frequently, causing the page to stutter. Please optimize it using React.memo, useMemo, and useCallback to reduce unnecessary re-renders.
```

Even if you don't understand these technical terms, simply telling AI "this page is stuttering" will prompt it to optimize for you.

### Rendering Large Data Sets

If you need to render a long list, such as 1000 items, AI might render all the data at once, causing the page to slow down.

How to let AI help you optimize?

Tell AI your specific needs:

```markdown
I have a list of 1000 items, and rendering all of them is too slow. Please implement virtual scrolling to render only the visible portion.
```

Or:

```markdown
Please implement pagination to display only 20 items at a time.
```

AI will provide a complete implementation plan, including library recommendations (like react-window) and code examples.

### Unoptimized Images

Images are usually the largest resources on a page. When generating code, AI often uses the original images without optimization.

You can ask AI to implement image optimization:

```markdown
Please implement lazy loading for images, so they only load when they enter the viewport.
```

Or:

```markdown
Please convert images to WebP format and add compression.
```

For image compression, you can use online tools like [TinyPNG](https://tinypng.com/) or ask AI to write a program for automated image processing.

### Synchronous API Requests

When AI generates complete front-end and back-end code, it typically implements it in the most straightforward wayâ€”making one request after another. This means the total request time is the sum of all individual request times, which can be slow.

For example:

```typescript
// AI might initially generate: Sequential requests (slow)
const user = await fetchUser();
const posts = await fetchPosts();
const comments = await fetchComments();
// Total time = t1 + t2 + t3
```

If you notice this issue, tell AI:

```markdown
These API requests are independent. Please change them to parallel requests to reduce total wait time.
```

AI will modify it like this:

```typescript
// Optimized: Parallel requests (fast)
const [user, posts, comments] = await Promise.all([
  fetchUser(),
  fetchPosts(),
  fetchComments()
]);
// Total time = max(t1, t2, t3)
```

This small optimization could potentially improve page load speed by 2 to 3 times.

### Lack of Caching

Caching is like keeping frequently used items close at hand, so you don't have to fetch them from afar each time. For example, if querying user information takes 1 second the first time, caching the result allows subsequent queries for the same user to return in 0.01 seconds.

![](https://pic.yupi.icu/1/cacheusage%E5%A4%A7.jpeg)

AI-generated code usually doesn't include caching mechanisms, causing the same data to be fetched repeatedly, wasting time.

You can tell AI:

```markdown
This data is fetched every time, which is too slow. Please add caching and store the data for 5 minutes.
```

Or:

```markdown
Please implement a simple in-memory cache to avoid repeated requests for the same data.
```

AI will choose an appropriate caching solution based on your scenario, such as browser caching, in-memory caching, or CDN.

## 3. Front-end Performance Optimization

Front-end performance directly impacts user experience, so we'll focus on this. This section will be more helpful for those with programming experience, but if you're a beginner, you can directly describe these optimization needs to AI and let it implement them for you.

### Code Splitting

AI-generated code might bundle all functionalities into one large file, forcing users to download the entire file when opening the page, which is slow.

You can tell AI:

```markdown
My JavaScript file is too large. Please implement code splitting to isolate the admin panel code and load it only when users access it.
```

AI will modify it like this:

```typescript
// AI might initially generate: Import all at once
import AdminPanel from './AdminPanel';

// Optimized: Lazy loading
const AdminPanel = lazy(() => import('./AdminPanel'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <AdminPanel />
    </Suspense>
  );
}
```

This way, only when users access the admin panel will the relevant code be loaded, potentially improving the homepage load speed by over 50%.

### Optimizing Rendering Performance

If AI-generated code uses React, rendering might become a bottleneck.

Optimization methods include:

1) Use `React.memo` to avoid unnecessary re-renders. For example, a user info display component doesn't need to re-render if the user info hasn't changed:

```typescript
const UserCard = React.memo(({ user }) => {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
});
```

2) Use `useMemo` to cache calculation results. If there are complex calculations, don't recompute them on every render:

```typescript
function TodoList({ todos }) {
  // Bad: Recompute on every render
  const completedCount = todos.filter(t => t.completed).length;
  
  // Good: Recompute only when todos change
  const completedCount = useMemo(
    () => todos.filter(t => t.completed).length,
    [todos]
  );
  
  return <div>Completed: {completedCount}</div>;
}
```

3) Use `useCallback` to cache functions. Avoid creating new functions on every render:

```typescript
function TodoList({ todos, onDelete }) {
  // Bad: Create new function on every render
  const handleDelete = (id) => {
    onDelete(id);
  };
  
  // Good: Cache function
  const handleDelete = useCallback((id) => {
    onDelete(id);
  }, [onDelete]);
  
  return <div>{/* ... */}</div>;
}
```

### Optimizing Resource Loading

Reduce the size and number of resources loaded initially.

1) Compress resources: Use Gzip or Brotli to compress JavaScript, CSS, and other text files. Modern build tools like Vite and Next.js usually do this automatically.

2) Tree Shaking: Remove unused code. Ensure your build tool enables Tree Shaking to bundle only the code actually used.

3) Preload critical resources: Preload resources needed for the initial render:

```html
<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
```

4) Lazy load non-critical resources: Delay loading resources not needed immediately:

```html
<script src="/analytics.js" defer></script>
```

### Optimizing CSS

CSS can also impact performance, which is often overlooked.

1) Avoid complex selectors: Complex CSS selectors take more time for browsers to match. Use simple class names.

2) Reduce reflows and repaints: Modifying the DOM triggers reflows and repaints, which are performance-intensive. Batch DOM modifications instead of making them one by one.

3) Use CSS animations instead of JavaScript: CSS animations are optimized by browsers and are smoother than JavaScript animations.

ðŸ’¡ If you want to learn more about front-end performance optimization, check out [Yupi's Front-end Performance Optimization Practical Video Tutorial](https://www.bilibili.com/video/BV1Wi33zmEAn/).

## 4. Back-end Performance Optimization

Back-end performance determines API response speed. Similarly, these optimizations can be achieved with AI; you just need to describe your requirements clearly.

### Database Query Optimization

Database queries are often the slowest part of the back-end. AI-generated database query code is usually straightforward and might have performance issues.

How to let AI help you optimize? Here are some ideas:

1) Ask AI to add indexes

```markdown
Queries on the email field of the user table are slow. Please add an index.
```

AI will provide specific SQL statements or ORM configurations.

2) Avoid N+1 queries

This is a common performance trap in AI-generated code. For example, if you need to fetch 10 posts and their author info, AI might generate:

```typescript
// AI might generate: N+1 queries (slow)
const posts = await db.posts.findMany(); // 1 query
for (const post of posts) {
  post.author = await db.users.findOne({ id: post.authorId }); // N queries
}
// 10 posts = 11 queries
```

You can tell AI: This code makes too many queries. Please optimize it to one query.

AI will modify it like this:

```typescript
// Optimized: One query (fast)
const posts = await db.posts.findMany({
  include: { author: true }
});
// 10 posts = 1 query
```

This optimization can improve API response speed by over 10 times.

3) Query only necessary fields

Tell AI:

```markdown
Please query only the necessary fields; don't use SELECT * to reduce data transfer.
```

AI will optimize the query statements.

### Using Caching

Using caching can significantly improve response speed.

1) In-memory caching: Cache frequently used data in memory, such as user info and configuration data. Use Redis or a simple Map.

2) HTTP caching: Set appropriate Cache-Control response headers (HTTP headers are server instructions to browsers on how to handle resources) to let browsers cache static resources.

```typescript
// Static resources: Cache for one year
res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');

// API data: Cache for 5 minutes
res.setHeader('Cache-Control', 'public, max-age=300');
```

3) CDN caching: CDN (Content Delivery Network) is like having warehouses across the country; users fetch resources from the nearest warehouse, which is faster than fetching from the headquarters. Using CDN to cache and accelerate static resource distribution can significantly improve global user access speed.

![](https://pic.yupi.icu/1/image-20260105153947917.png)

### Asynchronous Processing

Don't make users wait for time-consuming operations.

For example, if a user uploads an image and thumbnails need to be generated, don't make the user wait for the generation to complete. Instead:

1. Return a success response immediately
2. Generate thumbnails asynchronously in the background
3. Update the database after generation

This greatly improves user experience.

### API Design Optimization

Good API design can also improve performance.

1) Batch operations: If you need to delete multiple items, don't send multiple requests; send them all at once:

```typescript
// Bad: Multiple requests
for (const id of ids) {
  await deleteItem(id);
}

// Good: Batch request
await deleteItems(ids);
```

2) Pagination and cursors: Don't return large amounts of data all at once; use pagination or cursors to return data in batches.

Pagination is like flipping through pages of a book; cursors are like bookmarks, remembering where you left off so you can continue from there next time. You can learn more about cursor mechanisms in [this article](https://www.codefather.cn/post/1823563686797688834).

3) GraphQL: GraphQL is a query language that allows clients to specify exactly what data they need, rather than the server returning a bunch of unused data. It's like ordering Ã  la carte instead of being limited to set menus.

## 5. Vibe Coding Performance Optimization in Practice

Let me use a few real-world cases to demonstrate how to optimize performance in Vibe Coding with AI. These are issues I encountered in actual projects.

### Case 1: Slow List

Problem: I used AI to create an article list page, but loading 100 articles was slow, causing the page to stutter.

My approach:

1) First, use the Performance tool to test and find that rendering 100 article card components took 2 seconds.

2) Take a screenshot of the test results and send it to AI along with the code:

```markdown
This list page is stuttering. Here are the performance test results [screenshot], and here is the code [code]. Please help me optimize it.
```

3) AI provided optimization suggestions: Use virtual scrolling, React.memo, and lazy loading for images.

4) I asked AI to implement these optimizations:

```markdown
Please implement virtual scrolling using the react-window library.
```

5) Tested the optimization results and confirmed they worked.

Finally, the page load time dropped from 3 seconds to 0.5 seconds, scrolling became smooth, and the entire optimization process took less than 10 minutes.

### Case 2: Slow Search

Problem: I used AI to implement a search feature, but searching was slow. Users had to wait half a second after each keystroke to see results.

My approach:

1) Observed through the browser's developer tools that each keystroke triggered an API request.

2) Told AI:

```markdown
The search is too slow; it sends a request on every keystroke. Please optimize it to send a request only after the user stops typing for 300ms and cancel previous requests.
```

3) AI implemented debounce (waiting for the user to stop typing before sending a request) and AbortController (canceling previous requests to avoid wasting resources).

4) I also asked AI to add caching:

```markdown
Please add search result caching to avoid repeated requests for the same search term.
```

Finally, searching became smooth, no longer stuttering, API requests were reduced by 80%, and backend resources were saved.

### Case 3: Slow Homepage

Problem: The homepage of the website I created with AI loaded slowly, taking 5 seconds to display content.

My approach:

1) Used Lighthouse to test and found that the JavaScript file was too large (2MB), and images were not optimized.

2) Sent the Lighthouse report screenshot to AI:

```markdown
Here is my performance test report [screenshot]. Please help me optimize it.
```

3) AI provided a series of optimization suggestions, and I asked it to implement them one by one:

- Please implement code splitting to delay loading unnecessary code.
- Please compress images and convert them to WebP format.
- Please configure CDN to accelerate static resources.
- Please enable Gzip compression.

4) Tested the effects after each optimization to ensure improvements.

Finally, the homepage load time dropped from 5 seconds to 1